<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>AI Writing Assistant & Text Analyzer</title>
  <style>
    :root {
      --bg-light: #f4f8ff; --text-light: #333; --card-light: #fff; --border-light: #e0e8f0;
      --bg-dark: #1a1a2e; --text-dark: #e0e0e0; --card-dark: #16213e; --border-dark: #2a3b5a;
      --primary: #007bff; --success: #28a745; --warning: #ffc107; --danger: #dc3545;
      --highlight-passive: rgba(255, 193, 7, 0.4);
    }
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      background: var(--bg-light); color: var(--text-light);
      margin: 0; display: flex; justify-content: center; align-items: flex-start;
      min-height: 100vh; padding: 20px; transition: background 0.3s, color 0.3s;
    }
    body.dark-mode { --bg-light: var(--bg-dark); --text-light: var(--text-dark); --card-light: var(--card-dark); --border-light: var(--border-dark); }
    
    .container {
      background: var(--card-light); padding: 30px; border-radius: 16px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1); width: 100%;
      max-width: 900px; transition: background 0.3s;
    }
    
    .header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; }
    h2 { color: var(--primary); margin: 0; }
    
    /* Dark Mode Toggle */
    .theme-switch { display:flex; align-items:center; cursor:pointer; }
    .switch { position:relative; display:inline-block; width:50px; height:26px; }
    .switch input { opacity:0; width:0; height:0; }
    .slider { position:absolute; cursor:pointer; top:0; left:0; right:0; bottom:0; background-color:#ccc; transition:.4s; border-radius:26px; }
    .slider:before { position:absolute; content:""; height:20px; width:20px; left:3px; bottom:3px; background-color:white; transition:.4s; border-radius:50%; }
    input:checked + .slider { background-color:var(--primary); }
    input:checked + .slider:before { transform:translateX(24px); }

    #textBox {
      width: 100%; box-sizing: border-box; min-height: 250px; padding: 15px; font-size: 17px; line-height: 1.7;
      border-radius: 8px; border: 1px solid var(--border-light); resize: vertical; background: transparent;
      color: var(--text-light); transition: border-color 0.3s;
    }
    #textBox:focus { outline: none; border-color: var(--primary); }
    #textBox:empty:before { content: attr(placeholder); color: #999; pointer-events: none; }

    .dashboard {
      margin-top: 25px; display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 15px;
    }
    .stat-card {
      background: var(--bg-light); padding: 20px; border-radius: 12px;
      border: 1px solid var(--border-light); text-align: center; transition: background 0.3s, border-color 0.3s;
    }
    .stat-card .label { font-size: 14px; color: #888; margin-bottom: 8px; display: block; }
    .stat-card .value { font-size: 28px; font-weight: bold; color: var(--primary); }

    .highlight-passive { background-color: var(--highlight-passive); }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h2>AI Writing Assistant</h2>
      <div class="theme-switch" id="themeToggler">
        <label class="switch">
          <input type="checkbox">
          <span class="slider"></span>
        </label>
      </div>
    </div>
    <div contenteditable="true" id="textBox" placeholder="Start writing here... Paste your text and see the magic!"></div>

    <div class="dashboard">
      <div class="stat-card">
        <span class="label">Words</span>
        <span class="value" id="wordCount">0</span>
      </div>
      <div class="stat-card">
        <span class="label">Characters</span>
        <span class="value" id="charCount">0</span>
      </div>
      <div class="stat-card">
        <span class="label">Sentences</span>
        <span class="value" id="sentenceCount">0</span>
      </div>
      <div class="stat-card" id="readabilityCard">
        <span class="label">Readability</span>
        <span class="value" id="readabilityScore">Good</span>
      </div>
      <div class="stat-card">
        <span class="label">Reading Time</span>
        <span class="value" id="readingTime">~0s</span>
      </div>
       <div class="stat-card">
        <span class="label">Passive Voice</span>
        <span class="value" id="passiveCount">0</span>
      </div>
    </div>
  </div>

<script>
const textBox = document.getElementById("textBox");
const themeToggler = document.getElementById("themeToggler");
const statValues = {
    wordCount: document.getElementById("wordCount"), charCount: document.getElementById("charCount"),
    sentenceCount: document.getElementById("sentenceCount"), readabilityScore: document.getElementById("readabilityScore"),
    readingTime: document.getElementById("readingTime"), passiveCount: document.getElementById("passiveCount")
};

// --- CORE FUNCTIONS ---

let debounceTimeout;
function onTextInput() {
    clearTimeout(debounceTimeout);
    debounceTimeout = setTimeout(updateAllStats, 300); // Debounce for 300ms
}

function updateAllStats() {
    const text = textBox.innerText;
    const trimmedText = text.trim();

    // Basic stats
    const words = trimmedText.length > 0 ? trimmedText.split(/\s+/).filter(w => w) : [];
    const wordCount = words.length;
    const charCount = text.length;
    
    // Improved sentence count (tries to ignore abbreviations)
    const sentences = trimmedText.length > 0 ? (trimmedText.match(/(?<!\b(?:[A-Z][a-z]|[A-Z])\.)[.!?]+(\s|$)/g) || []) : [];
    const sentenceCount = sentences.length || (wordCount > 0 ? 1 : 0);

    // Update basic stats UI
    statValues.wordCount.textContent = wordCount;
    statValues.charCount.textContent = charCount;
    statValues.sentenceCount.textContent = sentenceCount;
    
    // Reading Time
    const wpm = 225;
    const readingTimeMins = wordCount / wpm;
    const mins = Math.floor(readingTimeMins);
    const secs = Math.round((readingTimeMins - mins) * 60);
    statValues.readingTime.textContent = mins > 0 ? `~${mins}m ${secs}s` : `~${secs}s`;

    if (wordCount > 10) {
        // Advanced analysis (only run on substantial text)
        const readability = calculateReadability(words, sentenceCount);
        statValues.readabilityScore.textContent = readability.level;
        document.getElementById('readabilityCard').style.color = readability.color;

        const passiveVoiceMatches = findPassiveVoice(text);
        statValues.passiveCount.textContent = passiveVoiceMatches.length;
        highlightText(passiveVoiceMatches);
    } else {
        // Reset advanced stats if text is too short
        statValues.readabilityScore.textContent = '...';
        document.getElementById('readabilityCard').style.color = 'var(--primary)';
        statValues.passiveCount.textContent = 0;
        removeHighlights();
    }
}

// --- GAME-CHANGING FEATURES ---

function countSyllables(word) {
    word = word.toLowerCase();
    if (word.length <= 3) return 1;
    word = word.replace(/(?:[^laeiouy]es|ed|[^laeiouy]e)$/, '');
    word = word.replace(/^y/, '');
    const matches = word.match(/[aeiouy]{1,2}/g);
    return matches ? matches.length : 0;
}

function calculateReadability(words, sentenceCount) {
    if (words.length === 0 || sentenceCount === 0) return { score: 0, level: '...', color: 'var(--primary)' };
    const totalSyllables = words.reduce((acc, word) => acc + countSyllables(word), 0);
    const score = 206.835 - 1.015 * (words.length / sentenceCount) - 84.6 * (totalSyllables / words.length);

    if (score >= 90) return { score, level: 'Very Easy', color: 'var(--success)' };
    if (score >= 70) return { score, level: 'Easy', color: 'var(--success)' };
    if (score >= 60) return { score, level: 'Good', color: 'var(--success)' };
    if (score >= 50) return { score, level: 'Okay', color: 'var(--warning)' };
    if (score >= 30) return { score, level: 'Hard', color: 'var(--danger)' };
    return { score, level: 'Very Hard', color: 'var(--danger)' };
}

function findPassiveVoice(text) {
    const passiveRegex = /\b(is|are|was|were|be|been|being)\s+([a-zA-Z]+ed\b|[a-zA-Z]+en\b|brought|bought|thought|sung|told|made|sent|built|done|seen)/gi;
    return [...text.matchAll(passiveRegex)];
}

function highlightText(matches) {
    removeHighlights();
    if (matches.length === 0) return;
    
    // Create a regex that matches any of the passive voice phrases
    const highlightRegex = new RegExp(matches.map(m => m[0]).join('|'), 'gi');
    
    const newHTML = textBox.innerHTML.replace(highlightRegex, match => `<span class="highlight-passive">${match}</span>`);
    
    // Save cursor position before changing HTML
    const sel = window.getSelection();
    const range = sel.rangeCount > 0 ? sel.getRangeAt(0) : null;
    const cursorPos = range ? getCursorPosition(textBox, range) : null;

    textBox.innerHTML = newHTML;

    if (cursorPos) restoreCursorPosition(textBox, cursorPos);
}

function removeHighlights() {
    textBox.innerHTML = textBox.innerText;
}


// --- UX & EVENT LISTENERS ---

// Fix: Paste as plain text to avoid formatting issues
textBox.addEventListener("paste", (e) => {
    e.preventDefault();
    const text = e.clipboardData.getData("text/plain");
    document.execCommand("insertText", false, text);
});

// Dark Mode Toggle
themeToggler.addEventListener('change', () => {
    document.body.classList.toggle('dark-mode');
});

textBox.addEventListener("input", onTextInput);
updateAllStats(); // Initial call

// --- CURSOR POSITION HELPERS (to prevent jumping on highlight) ---
// These are complex but necessary for a good UX with highlighting.
function getCursorPosition(parent, range) { let pos=0; const treeWalker=document.createTreeWalker(parent,Node.TEXT_NODE); while(treeWalker.nextNode()){ if(treeWalker.currentNode===range.startContainer){ pos+=range.startOffset; return pos; } pos+=treeWalker.currentNode.length; } return pos; }
function restoreCursorPosition(parent,pos){ const treeWalker=document.createTreeWalker(parent,Node.TEXT_NODE); let currentPos=0; while(treeWalker.nextNode()){ const nodeLength=treeWalker.currentNode.length; if(currentPos+nodeLength>=pos){ const range=document.createRange(); range.setStart(treeWalker.currentNode,pos-currentPos); range.collapse(true); const sel=window.getSelection(); sel.removeAllRanges(); sel.addRange(range); return; } currentPos+=nodeLength; } }
</script>
</body>
</html>
